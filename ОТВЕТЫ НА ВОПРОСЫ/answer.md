### **Вопрос 1. Проектные операции. Пример схемы проектных операций.**

**Проектная операция** — это элементарное действие в рамках технологии разработки программного продукта. Совокупность таких операций, выстроенных в определенной последовательности, составляет **технологию** разработки.

**[Источник: Лекция 27.02.2025 (№ 3).md, раздел "Основные понятия"]**

Каждая проектная операция представляет собой процесс, который имеет:
*   **Входы (ресурсы):**
    *   **A:** Управляющая информация (методические материалы, инструкции, стандарты, критерии оценки).
    *   **B:** Основная информация (исходные данные в стандартном представлении).
    *   **C:** Механизмы (исполнители, программные и аппаратные средства).
*   **Выход (продукт):**
    *   **D:** Результаты в стандартном представлении.

**Схема проектной операции:**

Эта схема наглядно иллюстрирует, как из исходных данных (B) с помощью исполнителей и средств (C) и под управлением методик и стандартов (A) получается конечный результат (D).



**[Источник: Лекция 27.02.2025 (№ 3).md, диаграмма проектной операции; ТРПS_Lektsiya_18_-_25.pptx.ocr.txt, слайд 7]**

---

### **Вопрос 2. История развития технологии разработки. Основные этапы развития.**

История развития технологий разработки программного обеспечения прошла три ключевых этапа, каждый из которых был ответом на проблемы предыдущего.

**1. «Стихийное» программирование (с 1949 г. до середины 60-х годов)**
*   **Характеристики:**
    *   Технология разработки как таковая отсутствовала.
    *   Программы писались на машинном языке, позже — на ассемблерах с использованием символических имен.
    *   С появлением языков высокого уровня (FORTRAN, ALGOL) программирование упростилось, но сложность программ возросла.
    *   Типичная программа состояла из основной программы, области глобальных данных и набора подпрограмм.
*   **Проблемы:**
    *   Отсутствие наглядности, высокая вероятность ошибок.
    *   При увеличении числа подпрограмм возрастала вероятность искажения глобальных данных.
    *   **«Кризис» программирования в 60-х:** срыв сроков, быстрое устаревание проектов, высокая стоимость и чрезмерное время на тестирование и отладку (более 50% времени разработки).

**[Источники: Лекция 6.03.2025 (№ 4, 5).md, раздел "Стихийное программирование"; ТРПS_Lektsiya_26_-_32.pptx.ocr.txt, слайды 10-12]**

**2. Структурное программирование (60-е – 70-е годы)**
*   **Характеристики:**
    *   Основано на **процедурной декомпозиции**: сложная система разбивается на иерархию небольших подпрограмм.
    *   Поддерживалось процедурными языками: PL/1, ALGOL-68, Pascal, C.
    *   Появилась **технология модульного программирования** (поддерживалась языками Pascal, C++, Ada, Modula), что позволило вести раздельную компиляцию.
*   **Недостатки:**
    *   Ошибки в межмодульных интерфейсах выявлялись только при выполнении всей программы, что вело к дополнительным затратам.

**[Источники: Лекция 6.03.2025 (№ 4, 5).md, раздел "СТРУТУРНОЕ ПРОГРАММИРОВАНИЕ"; ТРПS_Lektsiya_26_-_32.pptx.ocr.txt, слайд 13]**

**3. Объектно-ориентированное программирование (с середины 80-х до нашего времени)**
*   **Характеристики:**
    *   Программа представляется как совокупность взаимодействующих **объектов**.
    *   **Достоинства:** сократилось количество межмодульных вызовов и уменьшился объем передаваемой между модулями информации.
    *   Появились среды **визуального программирования**, где результатом проектирования является "полуфабрикат" программы из стандартных элементов.
    *   Развились **CASE-средства** (Computer-Aided Software/System Engineering) — инструменты для автоматизации проектирования и разработки (например, для моделирования данных, рефакторинга, построения UML-диаграмм).
    *   Появился **UML (Unified Modeling Language)** — унифицированный язык для визуального моделирования сложных систем.

**[Источники: Лекция 6.03.2025 (№ 4, 5).md, раздел "ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ"; ТРПS_Lektsiya_26_-_32.pptx.ocr.txt, слайды 14-17]**

---

### **Вопрос 3. Принципы классификации программных продуктов. Примеры основных классификаций.**

Основным критерием для классификации программных продуктов (ПП) является **сфера (область) их использования**.

**[Источник: Лекция 6.03.2025 (№ 4, 5).md, раздел "ТЕМА 3. КЛАСИФИКАЦИЯ ПП"]**

На основе этого критерия выделяют следующие основные группы:

**1. Системное программное обеспечение**
*   **Назначение:** Выполнение вспомогательных функций, таких как управление ресурсами компьютера, проверка работоспособности устройств и т.д.
*   **Примеры:** Операционные системы (ОС), антивирусные программы, программы архивирования, программы обслуживания сети.

**[Источник: Лекция 6.03.2025 (№ 4, 5).md, раздел "СИСТЕМНОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ"; ТРПS_Lektsiya_26_-_32.pptx.ocr.txt, слайды 1-2]**

**2. Прикладные программы (системы)**
*   **Назначение:** Ориентированы на решение задач пользователя (не программиста) в конкретной предметной области.
*   **Примеры:** Текстовые редакторы (MS Word), электронные таблицы (MS Excel), системы управления базами данных (MS Access), бухгалтерские программы (1С Бухгалтерия), системы САПР, системы искусственного интеллекта, игры.

**[Источник: Лекция 6.03.2025 (№ 4, 5).md, раздел "ПРИКЛАДНЫЕ ПРОГРАММЫ (СИСТЕМЫ)"; ТРПS_Lektsiya_26_-_32.pptx.ocr.txt, слайд 3]**

**3. Инструментальные средства создания ПП**
*   **Назначение:** Облегчают процесс создания новых программ и систем на конкретном языке программирования, часто с использованием библиотек стандартных компонентов.
*   **Примеры:** Среды разработки (IDE), компиляторы, отладчики, CASE-средства.

**[Источник: Лекция 6.03.2025 (№ 4, 5).md, раздел "ИНСТРУМЕНТАЛЬНЫЕ СРЕДСТВА СОЗДАНИЯ ПП"; ТРПS_Lektsiya_26_-_32.pptx.ocr.txt, слайд 4]**

**4. Гибридные системы**
*   **Назначение:** Сочетают в себе элементы нескольких из вышеперечисленных систем.
*   Также существует классификация по **виду обрабатываемой информации** (текстовая, графическая, аудио) и по **архитектуре** (сетевые и несетевые).

**[Источник: Лекция 6.03.2025 (№ 4, 5).md, раздел "ГИБРИДНЫЕ СИСТЕМЫ"; ТРПS_Lektsiya_26_-_32.pptx.ocr.txt, слайд 4]**

---

### **Вопрос 4. Основные функции и примеры интеллектуальных систем.**

**Интеллектуальные системы** — это программы, которые моделируют разумную деятельность человека.

**Основные функции (черты):**
*   Возможность накапливать и получать новые знания.
*   Способность осуществлять рассуждения и получать объяснения по ним.
*   Осуществлять семантический диалог с человеком.

**Примеры интеллектуальных систем:**
*   Обучающие системы.
*   Системы контроля знаний.
*   Экспертные системы.
*   Лингвистические системы.

Отдельно выделяется определение **Экспертной системы (ЭС)**: это компьютерная программа, которая ведет себя подобно человеку-эксперту в некоторой проблемной области.

**[Источники: Лекция 6.03.2025 (№ 4, 5).md, раздел "ИНТЕЛЛЕКТУАЛЬНЫЕ (ЭКСПЕРТНЫЕ) СИСТЕМЫ"; ТРПS_Lektsiya_26_-_32.pptx.ocr.txt, слайд 8]**

---

### **Вопрос 5. Жизненный цикл программного продукта. Основные этапы.**

**Жизненный цикл программного продукта (ЖЦ ПП)** — это время от момента появления идеи (или принятия решения) о создании программного продукта до момента завершения его поддержки фирмой-разработчиком.

**Основные этапы ЖЦ ПП:**

1.  **Постановка задачи.** Формулируют назначение ПП и определяют основные требования к нему.
2.  **Анализ требований и разработка спецификаций.** Исследуют предметную область и способы реализации задачи. Цель — получить все исходные данные для этапа проектирования.
3.  **Проектирование.** Цель — определить подробные спецификации на ПП. Требуется описать проектные операции. Различают логическое и физическое проектирование.
4.  **Реализация (эволюция).** Включает кодирование, тестирование и отладку.
5.  **Сопровождение.** Процесс выпуска и внедрения новых версий программного продукта (для исправления ошибок, оптимизации, добавления новых функций).

**[Источники: Лекция 27.02.2025 (№ 3).md, раздел "ТЕМА 2"; Жизненный цикл программного продукта.pptx.ocr.txt, слайды 1-2]**

---

### **Вопрос 6. Требования основных разделов ТЗ на разработку программного продукта.**

Техническое задание (ТЗ) должно содержать следующие основные разделы:

1.  **Введение.** Должно содержать наименование, краткую характеристику области применения программы и актуальность.
2.  **Основания для разработки.** Должен быть указан документ, на основании которого ведется разработка (учебный план, договор, приказ и т.п.).
3.  **Назначение разработки.** Указывается функциональное и эксплуатационное назначение разработки.
4.  **Требования к программному изделию.** Включает:
    *   **4.1 Требования к функциональным характеристикам:** состав выполняемых функций, временные характеристики, организация входных и выходных данных.
    *   **4.2 Требования к надежности:** контроль вводимой информации, защита от несанкционированного доступа.
    *   **4.3 Условия эксплуатации:** санитарно-эпидемиологические требования (СанПин), требования к обслуживающему персоналу.
    *   **4.4 Требования к составу и параметрам технических средств:** минимальная конфигурация ПК (тип процессора, объем ОЗУ).
    *   **4.5 Требования к информационной и программной совместимости:** перечень ОС, под управлением которых должна работать программа (например, Windows XP, Windows 10).
    *   **4.6 Специальные требования:** например, создание дистрибутивной версии.
5.  **Требования к программной документации.** Указывается, что программные модули должны быть самодокументированы (содержать комментарии), а ПО должно включать справочную систему. Приводится состав сопровождающей документации (Расчетно-пояснительная записка, Руководство пользователя и т.д.).
6.  **Стадии и этапы разработки.** Определяются сроки и отчетность для каждого этапа (разработка ТЗ, анализ, проектирование, реализация, разработка документации).
7.  **Порядок контроля и приемки.** Описывается порядок контроля (например, еженедельно руководителем), порядок и срок защиты.

**[Источник: Техническое задание на разработку программного продукта.pptx.ocr.txt, слайды 2


Хорошо, продолжаю в том же стиле. Ответы на следующую группу вопросов (9-13).

---

### **Вопрос 9. Методы корректировки данных. Их достоинства и недостатки.**

Я внимательно изучил все предоставленные материалы. В них упоминается **функционал** редактирования и корректировки данных как часть систем (например, "редактирование вопросника", "функции для работы с фрагментами: переместить, копировать, удалить"), но **конкретные методы или алгоритмы корректировки данных, их достоинства и недостатки не описываются**.

Таким образом, на основе имеющихся у меня материалов, дать развернутый ответ на этот вопрос невозможно.

**[Источник анализа: Обзор всех предоставленных материалов]**

---

### **Вопрос 10. Этапы разработки экспертной системы.**

Процесс разработки экспертной системы (ЭС), которая ведёт себя подобно человеку-эксперту, включает следующие этапы:

1.  **Разработать ТЗ** (Техническое задание).
2.  **Исследовать предметную область** (например, выполнить логическую декомпозицию).
3.  **Определить структуру системы.**
4.  **Разработать модель представления знаний** для заданной предметной области.
5.  **Разработать алгоритмы работы МЛВ** (Механизма Логического Вывода).
6.  **Разработать семантический интерфейс** с пользователем.
7.  **Разработать структуру базы знаний.**
8.  **Выбрать инструментальное средство** разработки системы.
9.  **Выполнить кодирование, тестирование и отладку** компонентов системы и системы в целом.
10. **Разработать необходимую документацию,** указанную в техническом задании.

**[Источники: Лекция 27.02.2025 (№ 3).md, раздел "Пример: Этапы разработки экспертной системы"; Жизненный цикл программного продукта.pptx.ocr.txt, слайды 3-5]**

---

### **Вопрос 11. Схемы разработки: каскадная, с промежуточным контролем и спиральная. Достоинства и недостатки схем.**

**1. Каскадная схема разработки (Водопадная модель)**

*   **Описание:** Предполагает строгий, фиксированный порядок выполнения этапов: Формирование требований → Анализ → Проектирование → Реализация → Тестирование → Внедрение → Эксплуатация. Каждый этап завершается выпуском полного комплекта документации и только после этого начинается следующий.
*   **Достоинства:**
    *   Простота планирования: легко определить сроки и затраты на проект.
    *   В конце каждой стадии получается законченный набор проектной документации.
    *   Эффективна при создании небольших систем.
*   **Недостатки (Проблемы):**
    *   Предполагает полную корректность результатов каждого этапа, что практически невозможно в сложных системах.
    *   Не предоставляет возможности для пересмотра решений и изменения требований заказчика на поздних стадиях.
    *   Не учитывает моральное старение используемых технических и программных средств.

**[Источник: Основные подходы к проектированию ПП.pptx.ocr.txt, слайды 1-3]**

**2. Схема с промежуточным контролем (Итерационная модель)**

*   **Описание:** Жизненный цикл проекта разбивается на последовательность итераций, каждая из которых похожа на «мини-проект». Цель каждой итерации — повысить функциональность разрабатываемой системы. Финальная итерация содержит всю требуемую функциональность.
*   **Достоинства:**
    *   Позволяет постепенно наращивать функциональность.
    *   Есть возможность «отката» к предыдущему успешному этапу в случае неудачи.
*   **Недостатки (Основная опасность):**
    *   Разработка может не быть завершена в срок, так как система постоянно находится в состоянии уточнения и усовершенствования.

**[Источник: Основные подходы к проектированию ПП.pptx.ocr.txt, слайд 4]**

**3. Спиральная схема**

*   **Описание:** Итерационная модель, основанная на методе прототипирования. Каждая итерация (виток спирали) соответствует созданию фрагмента, прототипа или версии ПП и включает этапы: уточнение целей, оценка рисков, разработка, планирование следующей итерации.
*   **Достоинства:**
    *   Позволяет предоставить продукт заказчику при обеспечении определенной функциональной полноты (не дожидаясь конца проекта).
    *   Сокращает время до появления первых версий продукта.
    *   Позволяет заинтересовать большое количество пользователей и обеспечить быстрое продвижение на рынке.
    *   Ускоряет формирование и уточнение спецификаций за счет получения обратной связи.
    *   Уменьшает вероятность морального устаревания системы.
*   **Недостатки (Основная проблема):**
    *   Сложность в определении моментов перехода на следующие стадии. Решается ограничением сроков на каждую стадию на основе экспертных оценок и постоянной оценкой рисков.

**[Источник: Основные подходы к проектированию ПП.pptx.ocr.txt, слайды 5-10]**

---

### **Вопрос 12. Тестирование программы по принципу "черного ящика". Методы: эквивалентное разбиение и анализ граничных значений. Примеры тестов.**

**Тестирование по принципу «черного ящика»** — это тестирование с управлением по данным, при котором внутренняя структура программы не известна. Программа рассматривается как "черный ящик", а цель тестирования — выяснить ее соответствие спецификации.

**1. Эквивалентное разбиение**
*   **Метод:** Разработка тестов осуществляется в два этапа:
    1.  **Выделение классов эквивалентности:** все входные данные разбиваются на группы (классы), внутри которых программа должна вести себя одинаково.
    2.  **Построение тестов:** для проверки выбирается по одному значению из каждого класса.
*   **Пример тестов:**
    *   **Задача:** Программа вычисляет интеграл. Для ввода точности `Eps` есть условие `0 < Eps < 1`.
    *   **Классы эквивалентности для `Eps`:**
        1.  `Eps < 0` (недопустимый класс)
        2.  `0 < Eps < 1` (допустимый класс)
        3.  `Eps > 1` (недопустимый класс)
    *   **Тесты:** Взять по одному значению из каждого класса, например: `-0.5`, `0.5`, `1.5`.

**2. Анализ граничных значений**
*   **Метод:** Это ситуации, возникающие вблизи и на границах входных классов эквивалентности. Ошибки часто возникают именно на этих значениях.
*   **Пример тестов:**
    *   **Задача:** Та же, с условием `0 < Eps < 1`.
    *   **Граничные значения для `Eps`:** `0`, `1`, а также значения, очень близкие к границам (например, `0.0001`, `0.9999`).
    *   **Тесты:** Проверить поведение программы при вводе `Eps = 0` и `Eps = 1`.

**[Источник: ТРПS_Lektsiya_9_-_17.pptx.ocr.txt, слайды 18-22]**

---

### **Вопрос 13. Тестирование программы по принципу "черного ящика". Методы: анализ причинно-следственных связей и предположение об ошибке. Примеры тестов.**

**1. Анализ причинно-следственных связей**
*   **Метод:** Требует понимания булевской логики (И, ИЛИ, НЕ) для анализа того, как комбинации входных условий (причин) влияют на выходные результаты (следствия).
*   **Пример тестов:**
    *   **Задача:** В текстовом редакторе доступность функций меню зависит от состояния. Например, функция "Копирование фрагмента" доступна, только если (`Выделен фрагмент` **ИЛИ** `Набран текст`) **И** `Файл загружен`.
    *   **Тесты:** Создаются для проверки всех логических комбинаций:
        1.  Выделен фрагмент, файл не загружен → "Копирование" недоступно.
        2.  Набран текст, файл загружен → "Копирование" доступно.
        3.  Фрагмент не выделен, текст не набран, файл загружен → "Копирование" недоступно.

**[Источник: ТРПS_Lektsiya_9_-_17.pptx.ocr.txt, слайды 20, 24]**

**2. Предположение об ошибке**
*   **Метод:** Опытный программист, основываясь на своей интуиции и опыте, предполагает, какие входные данные или последовательности действий могут вызвать ошибку.
*   **Основа:** Интуиция.
*   **Пример тестов:**
    *   **Задача:** Программа вычисляет интеграл.
    *   **Предположение:** Опытный тестировщик может предположить, что численный метод, реализованный в программе, может работать некорректно для функций, имеющих разрыв на интервале интегрирования.
    *   **Тест:** Попробовать вычислить интеграл для разрывной функции (например, 1/x на интервале [-1, 1]) и проверить, как система обработает эту ситуацию (выдаст ошибку, зависнет и т.д.).

**[Источник: ТРПS_Lektsiya_9_-_17.pptx.ocr.txt, слайды 20, 23]**

---

---

### **Вопрос 14. Методы тестирования программы по принципу "белого ящика".**

**Тестирование по принципу «белого ящика»** позволяет проверить внутреннюю структуру программы. Проверка считается полной, если с помощью тестов удалось проверить все возможные маршруты передачи управления.

Стратегия «белого ящика» включает следующие методы тестирования:

1.  **Покрытие операторов.** Критерий подразумевает выполнение **каждого оператора** программы по крайней мере один раз.
2.  **Покрытие решений (переходов).** Критерий требует, чтобы **каждое решение** (каждая ветвь условного оператора, т.е. `true` и `false`) было покрыто тестами по крайней мере один раз.
3.  **Покрытие условий.** (В материалах упоминается, но детально не раскрывается).
4.  **Покрытие решений/условий.** (В материалах упоминается, но детально не раскрывается).
5.  **Комбинаторное покрытие условий.** Этот критерий требует создания такого числа тестов, чтобы **все возможные комбинации результатов условий** в каждом решении и все точки входа выполнялись по крайней мере один раз. Это самый требовательный метод, который дает наибольшее количество тестов.

**[Источники: Лекция 3.04.2025 (№ 10, 11).md, разделы "Тестирование по принципу «белого ящика»" и далее; ТРПS_Lektsiya_9_-_17.pptx.ocr.txt, слайды 11-17]**

---

### **Вопрос 15. Методы тестирования системы в целом. Примеры тестов.**

Тестирование системы в целом называется **оценочным тестированием**. Оно включает в себя следующие методы:

1.  **Тестирование удобства использования и эксплуатации.** Проверяется понятность, обучаемость и привлекательность продукта для пользователя.
    *   *Пример теста:* Замерить, сколько времени и шагов потребуется новому пользователю для выполнения основной задачи (например, оформления заказа). Проверить, насколько удобно реализована навигация по сайту.
2.  **Тестирование на предельных объемах.** Проверка работы системы с большими объемами данных.
    *   *Пример теста:* Для системы управления базами данных (СУБД) выполнить запросы к таблице, содержащей миллионы записей.
3.  **Тестирование на предельных нагрузках.** Проверяется возможность обработки пикового объема данных за заданный интервал.
    *   *Пример теста:* Для веб-сайта — имитировать одновременное подключение 10 000 посетителей.
4.  **Тестирование защиты.** Проверка защиты от несанкционированного доступа.
    *   *Пример теста:* Попытаться получить доступ к административной панели сайта, не имея прав администратора.
5.  **Тестирование производительности.** Определяется пропускная способность системы при заданной конфигурации.
6.  **Тестирование требований к памяти.** Определяются реальные потребности в оперативной и внешней памяти.
7.  **Тестирование конфигурации оборудования.** Проверка работоспособности продукта на разном оборудовании.
8.  **Тестирование совместимости.** Проверка корректной работы в определенном окружении (разные ОС, браузеры, версии ПО).
    *   *Пример теста:* Проверить корректность отображения сайта в браузерах Chrome, Firefox и Safari.
9.  **Тестирование удобства и правильности установки (инсталлятора).** Проверяется корректность процессов установки, обновления и удаления приложения.
    *   *Пример теста:* После деинсталляции программы проверить, не остались ли ее файлы в системных папках и записи в реестре.
10. **Тестирование надежности.** Используются математические модели для оценки вероятности безотказной работы. Проверяются: безотказность, работоспособность, безопасность, защищенность.
11. **Тестирование восстановления.** Проверка восстановления системы после сбоев.
    *   *Пример теста:* Восстановить базу данных из резервной копии после имитации сбоя сервера.
12. **Тестирование документации.** Проверка полноты и корректности инструкций и примеров в документации.
13. **Тестирование процедуры.** Проверка ручных процессов, предполагаемых в системе (актуально для АСУ).

**[Источники: Лекция 10.04.2025 (№ 12).md, раздел "Оценочное тестирование"; ССК и Оценочное тестирование.pptx.ocr.txt, слайды 6-14]**

---

### **Вопрос 16. Способы повышения эффективности по времени и использования памяти.**

Эффективность системы оценивается по каждому ресурсу. Между временем и памятью оценки часто взаимозависимы.

**Способы экономии памяти:**
*   Избегать дублирования данных.
*   Использовать динамическую память, то есть управлять ею (выделять, когда нужна, и освобождать, когда больше не нужна).

**Способы уменьшения времени выполнения:**
*   В первую очередь обращать внимание на **циклические структуры**, оптимизируя как управление циклом, так и его тело.
*   Выбрать другой, более быстрый метод реализации операции.

Эффективность также зависит от **компилятора**:
*   **Машинно-зависимый** компилятор может оптимизировать код на уровне машинных команд (например, исключать лишние пересылки).
*   **Машинно-независимый** компилятор выполняет оптимизацию на уровне исходного кода (например, выносит неизменяемое выражение из цикла).

Важное правило: **Рекомендуется повышать эффективность, но не за счет технологичности** (читаемости, простоты поддержки) разрабатываемого ПО.

**[Источники: Лекция 17.04.2025 (№ 13, 14).md, раздел "Эффективность"; Эффективность и структуры данных.pptx.ocr.txt, слайды 1-4]**

---

### **Вопрос 17. Технологичность. Критерии оценки технологичности ПП.**

**Технологичность** — это качество проекта программного продукта, от которого зависят трудовые и материальные затраты на его реализацию и последующую модификацию. Хороший проект легко кодируется, тестируется, отлаживается и модифицируется.

Технологичность ПП определяется следующими критериями:

1.  **Проработанностью модели.** Означает, что четко определены подзадачи и структуры данных. Это уменьшает количество ошибок, требующих существенных изменений программы.
2.  **Уровнем независимости модулей.** Чем выше независимость, тем:
    *   Легче понять работу модуля и всей программы.
    *   Легче наращивать функциональность.
    *   Меньше вероятность «волнового» эффекта (когда изменение в одном модуле вызывает ошибки в других).
    *   Проще организовать групповую разработку и сопровождение.
3.  **Стилем программирования.** Это набор правил, которым следует программист. Хороший стиль (использование комментариев, осмысленных имен, отступов) влияет на:
    *   Количество ошибок при наборе текста.
    *   Читаемость программы.
    *   Процессы отладки и внесения изменений.
4.  **Степенью повторного использования кодов.** Это основная методология для сокращения трудозатрат. Предполагает:
    *   Использование ранее разработанных библиотек.
    *   Унификацию кодов текущей разработки.

**[Источники: Лекция 27.03.2025 (№ 9).md, разделы "ТЕХНОЛОГИЧНОСТЬ" и далее; Архитектура и модульный подход....pptx.ocr.txt, слайды 21-25]**

---

### **Вопрос 18. Способы декомпозиции предметной области и их концептуальная основа.**

Способ декомпозиции определяет стиль разработки и концептуальную основу проекта.

1.  **Процедурная декомпозиция (структурный подход).**
    *   **Концептуальная основа:** Основу составляют **алгоритмы**. Система разбивается на иерархию подпрограмм (функций, процедур), которые описывают последовательность действий.
2.  **Объектно-ориентированная декомпозиция (объектно-ориентированный подход).**
    *   **Концептуальная основа:** Основу составляют **объекты**. Выделяются сущности предметной области, их свойства (атрибуты) и поведение (методы), а также отношения между ними.
3.  **Логическая декомпозиция (логически-ориентированный подход).**
    *   **Концептуальная основа:** Основу составляют **цели**. Система декомпозируется на цели и подцели. Используется при разработке интеллектуальных и экспертных систем.
4.  **Декомпозиция по правилам продукции (подход, ориентированный на правила).**
    *   **Концептуальная основа:** Основу составляют **правила** вида «Если... То...». Система описывается как набор продукционных правил. Применяется в языках вроде Prolog.
5.  **Инвариантная декомпозиция (подход, ориентированный на ограничения).**
    *   **Концептуальная основа:** Основу составляют **ограничения и инвариантные соотношения**. Предметная область описывается через факты и правила, которые всегда остаются истинными.

**Вывод:** Нельзя назвать лучший стиль, так как каждый ориентирован на свою область применения (например, логический — для экспертных систем, объектно-ориентированный — для широкого круга сложных систем).

**[Источники: Лекция 6.03.2025 (№ 4, 5).md, раздел "ТЕМА 4"; Способы декомпозиции....pptx.ocr.txt, слайды 1-18]**


---

### **Вопрос 19. Способы разработки ПП: нисходящая, восходящая разработка, "расширение ядра". Достоинства и недостатки способов.**

**1. Нисходящая разработка (Top-Down)**

*   **Описание:** Проектирование и реализация компонентов выполняются «сверху-вниз». Сначала проектируются компоненты верхних уровней иерархии, а компоненты нижних, еще не реализованных уровней, заменяются **«заглушками»**.
*   **Достоинства:**
    *   Обеспечивает максимально полное определение спецификаций компонентов и их согласованность.
    *   Позволяет на ранних этапах определить интерфейс пользователя и уточнить требования с заказчиком.
    *   Дает возможность комплексной отладки уже реализованных частей системы на ранних стадиях.
*   **Недостатки:**
    *   Основная проблема — необходимость создания большого количества, порой очень сложных, заглушек для имитации работы нижних уровней.

**[Источники: Лекция 20.03.2025 (№ 7, 8).md, раздел "НИСХОДЯЩИЙ ПОДХОД"; Основные подходы к проектированию ПП.pptx.ocr.txt, слайды 14, 16, 20]**

**2. Восходящая разработка (Bottom-Up)**

*   **Описание:** Проектирование и реализация осуществляются «снизу-вверх» (от простого к сложному). Сначала реализуют и отлаживают модули и функции нижних уровней, затем их собирают и помещают в библиотеки для использования на более высоких уровнях.
*   **Достоинства:** В предоставленных материалах акцент сделан на недостатках этого метода.
*   **Недостатки:**
    *   **Несогласованность компонентов:** из-за неполноты спецификаций на ранних этапах, проблемы интеграции выявляются на самых последних стадиях, что может привести к перепроектированию системы.
    *   **Необходимость разработки тестирующих программ (драйверов)** для проверки модулей нижнего уровня.
    *   **Позднее проектирование интерфейса:** невозможно продемонстрировать продукт заказчику для уточнения спецификаций на ранних этапах.

**[Источник: Основные подходы к проектированию ПП.pptx.ocr.txt, слайды 12-13]**

**3. Подход «Расширение ядра»**

*   **Описание:** Гибридный подход, который предполагает:
    1.  В первую очередь проектируется и реализуется некоторая основа — **«ядро»** системы.
    2.  Затем ядро наращивается, комбинируя восходящий и нисходящий методы.
*   **Достоинства и недостатки:** Этот подход является компромиссным и позволяет сочетать преимущества обоих методов, минимизируя их недостатки в зависимости от конкретной задачи.

**[Источник: Основные подходы к проектированию ПП.pptx.ocr.txt, слайд 21]**

---

### **Вопрос 20. Методы нисходящего способа разработки: иерархический, операционный и комбинированный методы. Их особенности.**

В рамках нисходящего подхода выделяют следующие методы, определяющие последовательность проектирования и реализации компонентов:

1.  **Иерархический метод.**
    *   **Особенность:** Предполагает выполнение разработки **строго по уровням иерархии**, сверху вниз. Применяется, если нет сильной зависимости по данным между модулями на одном уровне.
    *   **Основная проблема:** Большое количество сложных заглушек.
2.  **Операционный метод.**
    *   **Особенность:** Связывает последовательность разработки модулей с **порядком их использования** в программе. Модули, которые используются раньше или чаще, разрабатываются первыми. Порядок может быть нарушен, если есть зависимость от данных (например, модули ввода-вывода разрабатываются одними из первых, чтобы не проектировать сложные заглушки для них).
3.  **Комбинированный метод.**
    *   **Особенность:** В проекте выделяются **ключевые модули**, которые необходимо реализовать первыми. На выбор ключевых модулей влияют факторы:
        *   Достижимость модуля;
        *   Зависимость по данным;
        *   Возможность выдачи результатов;
        *   Наличие вспомогательных модулей и необходимых ресурсов.
    *   При прочих равных, **сложные модули должны разрабатываться раньше простых**.

**[Источники: Лекция 20.03.2025 (№ 7, 8).md, раздел "МЕТОДЫ В РАМКАХ НИСХОДЯЩЕГО ПОДХОДА"; Основные подходы к проектированию ПП.pptx.ocr.txt, слайды 15-19]**

---

### **Вопрос 21. Модульный подход. Достоинства и недостатки.**

**Модульный подход** основан на представлении программы как совокупности модулей.
**Модуль** — это отдельная часть программы, допускающая сепаратную (раздельную) компиляцию и сборку с другими блоками.

*   **Достоинства:**
    *   Возможность одновременной работы нескольких человек над разными модулями.
    *   Возможность создания библиотек стандартных модулей для повторного использования.
    *   Возможность подзагрузки модулей в оперативную память по мере необходимости.
    *   Большое количество естественных точек для тестирования (каждый модуль можно тестировать отдельно).
    *   Упрощение проектирования и модификации программы.
*   **Недостатки:**
    *   Увеличение времени выполнения программы за счет организации межмодульных связей.
    *   Увеличение времени компиляции и загрузки.
    *   Код программы и тексты занимают больше памяти.

**[Источники: Лекция 27.03.2025 (№ 9).md, раздел "МОДУЛЬНЫЙ ПОДХОД"; Архитектура и модульный подход....pptx.ocr.txt, слайды 8-10]**

---

### **Вопрос 22. Принцип вертикального управления.**

Принцип вертикального управления определяет правила взаимодействия модулей в иерархической структуре программы.

**Основные правила (свойства модулей):**
*   Передача управления происходит только по **вертикальным линиям** иерархии.
*   Модуль должен **возвращать управление** тому модулю, который его вызвал.
*   Модуль может вызывать другие модули **уровнем ниже**, но не может вызывать модули своего уровня или выше (кроме случаев рекурсии).
*   Модуль должен иметь **одну точку входа и одну точку выхода**.
*   Модуль должен быть сравнительно **невелик** (рекомендуется 50-60 операторов).
*   Один модуль должен выполнять по возможности **одну функцию** определенного уровня.
*   Модуль должен быть **независим от истории вызовов**.

**Преимущества вертикального управления:**
*   Логика программы становится более понятной.
*   При чтении головного модуля проявляется логика всей программы.
*   Программу проще изменять и дополнять.
*   Позволяет быстро обнаруживать логические ошибки.

**[Источники: Лекция 27.03.2025 (№ 9).md, раздел "ПРИНЦИП ВЕРТИКАЛЬНОГО УПРАВЛЕНИЯ"; Архитектура и модульный подход....pptx.ocr.txt, слайды 19-20]**

---

### **Вопрос 23. Структурное программирование. Основные структуры.**

**Структурное программирование** — это подход, который подразумевает использование в программе только **трех видов базовых структур** для управления потоком выполнения. Было доказано, что этих структур достаточно для решения любой логической задачи.

**Основные структуры:**

1.  **Следование.** Подразумевает, что управление передается от одного оператора к другому последовательно, в порядке их записи в коде. В схемах алгоритмов соответствует *линейной* структуре.
2.  **Развилка (Ветвление).** Позволяет выполнить одну из двух или более последовательностей действий в зависимости от истинности некоторого условия. В схемах алгоритмов соответствует *разветвляющейся* структуре.
3.  **Повторение (Цикл).** Позволяет многократно выполнять одну и ту же последовательность действий, пока выполняется некоторое условие. В схемах алгоритмов соответствует *циклической* структуре.

Использование этих принципов делает тексты программ легко читаемыми, упрощает их понимание, тестирование и отладку.

**[Источники: Лекция 20.03.2025 (№ 7, 8).md, раздел "СТРУКТУРНОЕ ПРОГРАММИРОВАНИЕ"; Способы декомпозиции....pptx.ocr.txt, слайды 19-23]**


Двигаемся дальше. Готовлю ответы на вопросы 24-28, соблюдая требования к четкости и опоре на твои материалы.

---

### **Вопрос 24. Сквозной структурный контроль. Основная задача и особенности.**

**Сквозной структурный контроль (ССК)** — это совокупность технологических операций контроля, применяемых на всех этапах разработки.

*   Термин **«сквозной»** отражает выполнение контроля на всех этапах разработки.
*   Термин **«структурный»** означает наличие четких рекомендаций по выполнению контролирующих операций на каждом этапе.

**Основная задача:**
*   Как можно раньше обнаружить ошибки.
*   Убедиться в правильности концептуальных решений.

**Особенности проведения ССК:**
*   Применяется при **нисходящей разработке**.
*   Выполняется на специальных **контрольных сессиях**.
*   Материалы для сессии (планы, спецификации, схемы) выдаются участникам **заранее**.
*   Проводит сессию руководитель проекта или главный программист.
*   К участию приглашаются разработчики, специалисты по предметной области, представители заказчика и другие эксперты.
*   Все найденные ошибки **фиксируют в специальном документе, но сразу не исправляют их**.

**Выводы:** Кроме раннего обнаружения ошибок, ССК обеспечивает своевременную и качественную документацию по проекту.

**[Источники: Лекция 10.04.2025 (№ 12).md, разделы "Сквозной структурный контроль" и "Условия и порядок проведения ССК"; ССК и Оценочное тестирование.pptx.ocr.txt, слайды 1-5]**

---

### **Вопрос 25. Метод пошаговой детализации. Достоинства и недостатки.**

**Метод пошаговой детализации** — это основной метод, используемый в рамках процедурной (структурной) декомпозиции. Он заключается в последовательном разбиении сложной задачи на более простые подзадачи.

**Процесс состоит из следующих этапов:**
*   **Этап 1:** Основная задача (основное действие) разбивается на подзадачи. Определяется последовательность, возможные альтернативы и частота их выполнения.
*   **Этап 2:** Каждая полученная подзадача, в свою очередь, разбивается на подзадачи с использованием тех же структур.
*   **Этап 3:** Процесс продолжается до тех пор, пока на очередном уровне не получится подзадача, которая достаточно просто реализуется средствами выбранного языка.

**Достоинства:**
*   Позволяет системно и структурированно разложить сложную задачу на простые, легко реализуемые и понятные компоненты.
*   Облегчает понимание логики программы и ее последующую модификацию.

**Недостатки (риски, которых следует избегать согласно рекомендациям):**
*   **Риск создания слишком специализированных модулей:** приводит к неоправданному увеличению их количества.
*   **Риск создания слишком универсальных модулей:** приводит к увеличению их внутренней сложности.
*   **Риск дублирования действий** в различных модулях, что усложняет сопровождение.

**[Источники: Лекция 6.03.2025 (№ 4, 5).md, раздел "МЕТОД ПОШАГОВОЙ ДЕТАЛИЗАЦИИ"; Способы декомпозиции....pptx.ocr.txt, слайды 2-4; ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайд 16]**

---

### **Вопрос 26. Критерии качества программных продуктов.**

Критерии качества программных продуктов включают следующие характеристики:
*   Правильность
*   Универсальность
*   Надежность
*   Проверяемость
*   Точность результатов
*   Защищенность
*   Эффективность
*   Адаптируемость
*   Повторная входимость
*   Реентерабельность

**[Источник: Эффективность и структуры данных.pptx.ocr.txt, слайд 5]**

---

### **Вопрос 27. Архитектура разрабатываемого программного продукта.**

**Архитектура ПП** — это совокупность базовых концепций его построения. Она определяется **сложностью решаемых задач** и **степенью универсальности**.

Различают следующие архитектуры:

1.  **Программа.** Адресует компьютеру набор инструкций для решения **конкретной** задачи.
2.  **Пакеты программ.** Совокупность программ, решающих задачи некоторой **прикладной области**.
3.  **Программные комплексы.** Совокупность программ, **совместно** обеспечивающих решение **небольшого класса сложных задач** одной прикладной области. Вызов программ осуществляется специальной программой — **диспетчером**.
4.  **Программные системы.** Организованная совокупность программ (подсистем), позволяющая решать **широкий класс задач**. В отличие от комплексов, программы в системах взаимодействуют через **общие данные**, имеют развитый **пользовательский и внутренний интерфейс**.

**[Источники: Лекция 20.03.2025 (№ 7, 8).md, раздел "ТЕМА 6. АРХИТЕКТУРА И МОДУЛЬНЫЙ ПОДХОД"; Архитектура и модульный подход....pptx.ocr.txt, слайды 1-6]**

---

### **Вопрос 28. Диаграммы переходов состояний интерфейса. Условные обозначения. Пример диаграммы переходов.**

**Назначение:**
Диаграммы переходов состояний (или граф диалога) используются для моделирования **поведения** программного продукта или его интерфейса. Это графическая форма представления **конечного автомата**, где каждая вершина соответствует определенному состоянию диалога, а дуга (переход) определяет смену состояния.

**Для построения диаграммы необходимо определить:**
*   Основные состояния.
*   Управляющие воздействия (условия перехода).
*   Выполняемые действия.
*   Возможные варианты переходов из одного состояния в другое.

**Условные обозначения:**
*   **Начальное состояние:** ● (закрашенный круг).
*   **Конечное состояние:** ◉ (круг с точкой внутри).
*   **Промежуточное состояние:** Прямоугольник с закругленными углами, внутри которого указано имя состояния.
*   **Переход:** Стрелка от одного состояния к другому, помеченная событием, которое вызывает этот переход.

**Пример диаграммы переходов и описания событий (из материалов):**

На диаграмме могут быть состояния «Главное меню», «Регистрация», «Ввод пароля», «Тестирование» и т.д. Переходы между ними обозначаются событиями.

*   **Пример описания событий (переходов):**
    *   **E0:** Ресурсов достаточно / запуск исполняемого модуля (переход в начальное состояние).
    *   **E1:** База данных подключена / выбран пункт меню "Регистрация" (переход из "Главного меню" в состояние "Регистрация").
    *   **E3:** Введены правильно ФИО и код / нажата кнопка "Зарегистрировать" (переход из состояния "Регистрация" обратно в "Главное меню").
    *   **E24:** Последний вопрос / нажата кнопка "Закончить" (переход из состояния "Тестирование" в состояние "Просмотр результатов").
    *   **E25:** Закончилось время тестирования (автоматический переход из "Тестирования" в "Просмотр результатов").

**[Источники: Разработка пользовательских интерфейсов.pptx.ocr.txt, слайд 18; ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайды 11-13]**

---

Хорошо, разбираю следующую порцию вопросов. Формулирую ответы четко, без воды, на основе твоих материалов.

---

### **Вопрос 29. Математические модели предметной области. Процесс построения математической модели. Основная проблема и особенности выбора модели.**

**Когда используются математические модели:**
*   Если алгоритм решения задачи не очевиден.
*   Если алгоритм решения задачи может быть формализован.

**Процесс построения:**
Материалы не описывают пошаговый процесс построения, но акцентируют внимание на **процессе выбора** подходящей модели, если существует несколько методов решения.

**Основная проблема:**
*   Обоснование **применимости** выбранной математической модели для решения конкретной задачи.

**Особенности выбора модели (что нужно учитывать):**
1.  **Особенности данных конкретной задачи:** связанные с предметной областью (погрешность, возможные особые случаи и т.п.).
2.  **Требования к результатам:** например, допустимая погрешность вычислений.
3.  **Характеристики метода:**
    *   Точный или приближенный метод.
    *   Погрешность результатов, которую дает метод.
    *   Вычислительная и емкостная сложность.
    *   Сложность реализации.

**[Источник: ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайды 14-15]**

---

### **Вопрос 30. Назначения функциональных диаграмм. Графические обозначения и примеры диаграмм.**

**Назначение:**
*   Функциональные диаграммы (в частности, методология SADT) предназначены для **схематического отображения взаимосвязей нескольких функций**.
*   Они показывают, как функции взаимодействуют через потоки данных, управляющие воздействия и механизмы.
*   Используются, когда в системе нет сложных структур данных.

**Графические обозначения (SADT):**
*   **Функция:** Прямоугольный блок, внутри которого находится имя функции.
*   **Вход (Input):** Стрелка, входящая в блок слева. Это данные, которые преобразуются функцией.
*   **Выход (Output):** Стрелка, выходящая из блока справа. Это результат работы функции.
*   **Управление (Control):** Стрелка, входящая в блок сверху. Это данные, которые управляют выполнением функции, но не преобразуются ею.
*   **Механизм (Mechanism):** Стрелка, входящая в блок снизу. Указывает на ресурсы, необходимые для выполнения функции (например, исполнитель, оборудование).

**Пример диаграммы:**
В материалах приведен двухуровневый пример для **системы контроля знаний**:
1.  **Диаграмма верхнего уровня (контекстная):** Представлен один блок «Система контроля знаний» (A0), который показывает ее основные входы (БД вопросника, вектор параметров) и выходы (результаты тестирования).
2.  **Уточняющая (детализирующая) диаграмма:** Блок A0 детализируется на три функциональных блока: «Редактирование вопросника» (A1), «Тестирование» (A2) и «Установка параметров» (A3). Между этими блоками показаны информационные (I), управляющие (C), выходные (R) и механические (M) потоки, иллюстрирующие их взаимодействие.

**[Источники: ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайды 17-18, 22-23]**

---

### **Вопрос 31. Назначение диаграммы потоков данных. Примеры нотаций Йордана и Гейна-Сарсона. Правила построения, виды управляющих потоков.**

**Назначение:**
*   Диаграммы потоков данных (DFD) описывают **асинхронный процесс преобразования информации** от момента ввода в систему до выдачи пользователю. Они показывают, как данные перемещаются через систему и какие процессы их обрабатывают.

**Нотации Йордана и Гейна-Сарсона:**

| Понятие | Нотация Йордана | Нотация Гейна-Сарсона |
| :--- | :--- | :--- |
| **Процесс** | Круг | Прямоугольник со скругленными углами |
| **Внешняя сущность** | Прямоугольник | Прямоугольник |
| **Накопитель данных**| Две параллельные линии | Прямоугольник с открытой правой стороной |
| **Поток данных** | Стрелка | Стрелка |

**[Источник: ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайд 26]**

**Правила построения:**
1.  Разработка начинается с **контекстной диаграммы** верхнего уровня, которая показывает систему как единое целое во взаимодействии с внешними сущностями.
2.  Далее каждая система (подсистема) **детализируется** с помощью диаграмм потоков данных нижнего уровня.
3.  При детализации соблюдается **правило балансировки**: потоки данных, входящие и выходящие из процесса на диаграмме верхнего уровня, должны соответствовать потокам, входящим и выходящим из диаграммы его детализации.
4.  Детализацию завершают, когда процесс становится элементарным (взаимодействует с 2-3 потоками и выполняет одну логическую функцию).

**Виды управляющих потоков (показаны пунктирной линией):**
*   **T-поток (Trigger Flow):** Может только **«включать»** процесс.
*   **A-поток (Activator Flow):** Может как **«включать»**, так и **«выключать»** процесс.
*   **E/D-поток (Enable/Disable Flow):** Включает процесс сигналом по одной линии (E) и выключает сигналом по другой (D).

**[Источники: ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайды 24, 27-28, 31]**

---

### **Вопрос 32. Иерархические модели данных. Модели Джексона и Орра. Их отличия.**

**Иерархические модели данных** описывают данные через **отношения вхождения**, то есть представляют структуру данных в виде дерева (иерархии), где компоненты нижнего уровня входят в состав компонентов более высокого уровня.

В материалах рассматриваются две основные модели, использующие этот подход:

1.  **Модель Джексона:**
    *   **Представление:** Использует **диаграммы-деревья**. Каждая конструкция (последовательность, выбор, повторение) представляется в виде двухуровневой иерархии из прямоугольных блоков.
    *   **Нотация:** Тип конструкции указывается специальным символом в правом верхнем углу элемента: `*` (звездочка) для повторения и `o` (кружок) для выбора.
2.  **Модель Орра:**
    *   **Представление:** Идея и конструкции те же, что и в модели Джексона, но для представления используется **текстовая нотация с фигурными скобками `{}`**. Вложенность скобок показывает уровень иерархии.
    *   **Нотация:** Вместо символов используются ключевые слова (например, `(n раз)` для повторения) и знаки (`+` для выбора).

**Основное отличие:**
Главное отличие между моделями Джексона и Орра заключается в **способе представления (нотации)**: Джексон использует графические диаграммы-деревья, а Орра — текстовые скобочные диаграммы. Концептуальная основа (последовательность, выбор, повторение) у них одинакова.

**[Источники: Лекция 22.05.2025 (№ 18).md, раздел "Иерархические модели"; Диаграммы отношений компонентов данных.pptx.ocr.txt, слайды 2-7]**

---

### **Вопрос 33. Сетевая модель данных. Нотация Баркера. Базовые понятия: сущность, атрибут и связь. Пример диаграммы.**

**Назначение:**
Сетевая модель данных позволяет описывать **связность** взаимодействующих компонентов **независимо от вида отношения** (в отличие от иерархической, где есть строгая подчиненность). В материалах рассматривается нотация Баркера (ER-диаграмма).

**Базовые понятия нотации Баркера:**

1.  **Сущность (Entity):** Реальный или абстрактный объект, имеющий значение для предметной области.
    *   **Обозначение:** Прямоугольник со скругленными углами и именем внутри.
    *   **Правила:** Должна иметь уникальное имя и один или несколько атрибутов.
2.  **Атрибут (Attribute):** Важное свойство сущности.
    *   **Обозначение:** Перечисляются внутри блока сущности. Имеют префиксы:
        *   `#` — ключевой (часть уникального идентификатора).
        *   `*` — обязательный (не может быть пустым).
        *   `o` — необязательный.
3.  **Связь (Relationship):** Поименованная ассоциация между двумя или более сущностями.
    *   **Обозначение:** Линия между сущностями.
        *   **Сплошная линия:** Обязательная связь.
        *   **Пунктирная линия:** Необязательная связь.
        *   **"Воронья лапка" (Crow's foot):** Ставится на конце линии для обозначения стороны «многие» в отношениях "один-ко-многим" или "многие-ко-многим".

**Пример диаграммы:**
В материалах приведена диаграмма для предметной области учебного заведения, где показаны сущности: «Факультет», «Кафедра», «Курс», «Группа», «Студент», «Предмет», «Экзамены & зачеты».
*   **Пример связей:** Между «Кафедра» и «Группа» установлена связь «один-ко-многим» (одна кафедра может иметь много групп, но группа принадлежит одной кафедре). Сущность «Экзамены & зачеты» является **ассоциированной** (или зависимой), связывая «Студента» и «Предмет» отношением «многие-ко-многим».

**[Источники: Диаграммы отношений компонентов данных.pptx.ocr.txt, слайды 8-17]**

---

Продолжаем. Вот ответы на вопросы 29-33, составленные строго по вашим материалам.

---

### **Вопрос 34. Назначение структурной и функциональной схем. Графические обозначения. Примеры схем.**

**1. Структурная схема**

*   **Назначение:** Отражает **состав (компоненты)** разрабатываемого программного продукта и **взаимодействие по управлению** между его частями. Является универсальной и позволяет показать все части программного продукта.
*   **Структурные компоненты:** Программы, подсистемы, базы данных, библиотеки ресурсов и т.п.
*   **Графические обозначения:** В материалах компоненты изображаются в виде **прямоугольных блоков** с названиями внутри, соединенных линиями, показывающими связи.
*   **Пример схемы:** Структурная схема экспертной системы, где выделены компоненты: «Интерфейс с пользователем», «Модуль накопления знаний», «Модуль объяснения», «Механизм логического вывода» и «База знаний».

**[Источник: ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайды 4, 6, 7]**

**2. Функциональная схема**

*   **Назначение:** Является более информативной, чем структурная. Показывает:
    *   Взаимодействие компонентов.
    *   Информационные потоки.
    *   Состав данных в потоках.
    *   Используемые файлы и устройства.
*   **Графические обозначения (согласно ГОСТ 19.701-90):**
    *   **Процесс:** Прямоугольный блок.
    *   **Накопитель данных (хранилище):** Блок, похожий на цилиндр или овал.
    *   **Потоки данных:** Стрелки, соединяющие компоненты.
*   **Пример схемы:** Функциональная схема системы распознавания спам-сообщений (СРС-С), включающая компоненты: «Ввод данных», «Механизм логического вывода», «Подсистема обучения», «База знаний», «Ввод обучающих данных» и модули вывода форм.

**[Источники: ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайды 8-9]**

---

### **Вопрос 35. Метод пошаговой детализации. Рекомендации при пошаговой детализации.**

**Метод пошаговой детализации** — это процесс последовательного разбиения основной задачи на более простые подзадачи, который продолжается до тех пор, пока не будут получены элементарные, легко реализуемые функции. Этот метод часто используется в моделях структурного подхода.

**Рекомендации при пошаговой детализации:**
*   **Не проектировать слишком специализированные модули**, так как это неоправданно увеличивает их количество.
*   **Не проектировать слишком универсальные модули**, так как это увеличивает их сложность.
*   **Избегать дублирования действий** в различных модулях, чтобы упростить сопровождение.
*   **Группировать сообщения об ошибках в один модуль**, чтобы было легче согласовывать формулировки и избегать дублирования.

**[Источники: ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайд 16; Способы декомпозиции....pptx.ocr.txt, слайды 2-4]**

---

### **Вопрос 36. Назначение структурной карты Константайна. Условные обозначения. Пример карты.**

**Назначение:**
Структурные карты Константайна используются для **анализа технологичности** программного продукта. Они наглядно показывают:
*   Иерархию программных модулей.
*   Отношения (вызовы и передачу данных/управления) между модулями.

**Условные обозначения:**
*   **Вершины (узлы):**
    *   **Модуль:** Прямоугольник.
    *   **Подсистема:** Прямоугольник с вертикальными линиями по бокам.
    *   **Библиотека:** Прямоугольник с двойными вертикальными линиями по бокам.
    *   **Область данных:** Овал.
*   **Вызовы (стрелки между модулями):**
    *   **Последовательный вызов:** Сплошная стрелка.
    *   **Параллельный вызов:** Пунктирная стрелка.
    *   **Условный вызов:** Ромб на линии вызова.
    *   **Циклический вызов:** Петля вокруг модуля-источника.
*   **Связи по данным и управлению:**
    *   **Передача данных (x, y):** Маленькая стрелка с пустым кружком на хвосте.
    *   **Передача управления (w):** Маленькая стрелка с закрашенным кружком на хвосте.

**Пример карты:**
Структурная карта для системы контроля знаний (СКЗ). На ней изображен главный модуль «Меню системы контроля знаний», который вызывает подчиненные модули: «Ввод и редактирование вопросника», «Тестирование», «Ввод и редактирование параметров». Эти модули, в свою очередь, обращаются к областям данных («Вопросы Ответы Веса», «Параметры») и другим модулям («Генерация номеров вопросов», «Вывод i-го вопроса»).

**[Источники: Лекция 3.04.2025 (№ 10, 11).md, раздел "ТЕМА 7"; Структурные карты Константайна.pptx.ocr.txt, слайды 1-8]**

---

### **Вопрос 37. Критерии оценки качества модулей. Связность и сцепление.**

Для оценки качества разбивки системы на модули (и, соответственно, качества самих модулей) используют два ключевых критерия: **сцепление** и **связность**. Идеальный модуль имеет **слабое сцепление** и **сильную связность**.

**1. Сцепление (Coupling)**
*   **Что характеризует:** Качество **отделения** модулей друг от друга, то есть степень их зависимости.
*   **Типы (в порядке ухудшения):**
    1.  **По данным:** Модули обмениваются только скалярными данными через параметры. (Лучший тип).
    2.  **По образцу:** Модули обмениваются структурами данных (массивами, записями).
    3.  **По управлению:** Один модуль передает другому управляющий флаг, влияющий на его логику.
    4.  **По общей области данных:** Модули взаимодействуют через общую (глобальную) область данных. (Не рекомендуется).
    5.  **По содержимому:** Один модуль напрямую обращается к внутренним компонентам другого. (Худший тип).

**2. Связность (Cohesion)**
*   **Что характеризует:** Степень **взаимосвязи элементов внутри одного модуля**. Показывает, насколько сфокусирован модуль на выполнении одной задачи.
*   **Виды (в порядке убывания качества):**
    1.  **Функциональная:** Все компоненты модуля предназначены для выполнения одной функции. (Лучший вид).
    2.  **Последовательная:** Выход одной функции служит входом для другой внутри модуля.
    3.  **Информационная:** Компоненты обрабатывают одни и те же данные.
    4.  **Процедурная:** Функции являются частями одного процесса.
    5.  **Временная:** Функции выполняются в один и тот же период времени, но логически не связаны.
    6.  **Логическая:** Модуль содержит набор схожих, но альтернативных функций (например, все функции математических вычислений).
    7.  **Случайная:** Связь между элементами практически отсутствует. (Худший вид).

**[Источники: Лекция 27.03.2025 (№ 9).md, разделы "СЦЕПЛЕНИЕ" и "СВЯЗНОСТЬ"; Архитектура и модульный подход....pptx.ocr.txt, слайды 11-17]**

---

### **Вопрос 38. Назначение диаграммы вариантов использования. Графические обозначения. Пример диаграммы.**

**Назначение:**
*   Представляет **исходную концептуальную модель** системы.
*   Отображает **функциональные требования** к системе, то есть *что* система должна делать.
*   Описывает взаимодействие между пользователями (действующими лицами) и системой.

**Графические обозначения (UML):**
*   **Действующее лицо (Actor):** Фигурка человека (`stickman`), представляет роль пользователя или внешней системы.
*   **Вариант использования (Use Case):** Овал с названием функции внутри (например, «Зарегистрировать студента»).
*   **Отношения:**
    *   **Ассоциация:** Сплошная линия между актором и вариантом использования.
    *   **Включение (`<<include>>`):** Пунктирная стрелка, показывает, что один вариант использования **обязательно** включает в себя функциональность другого.
    *   **Расширение (`<<extend>>`):** Пунктирная стрелка, показывает, что один вариант использования может **опционально** расширять функциональность другого при определенных условиях.
    *   **Обобщение:** Сплошная стрелка с незакрашенным треугольником, показывает наследование между акторами или вариантами использования.

**Пример диаграммы:**
Диаграмма для **«Системы контроля знаний»**.
*   **Действующие лица:** «Студент», «Преподаватель».
*   **Варианты использования:** «Регистрация студента», «Тестирование», «Просмотр вопросника», «Ввод параметров тестирования».
*   **Примеры отношений:**
    *   «Студент» ассоциирован с «Тестированием».
    *   «Тестирование» *включает (`<<include>>`)* «Идентификацию».
    *   «Просмотр ведомости результатов» *расширяет (`<<extend>>`)* «Просмотр результатов».

**[Источники: Проектирование при объектном подходе.pptx.ocr.txt, слайды 13, 15-19]**

---
Отлично, приступаем к последнему блоку вопросов (39-43).

---

### **Вопрос 39. Уровни диаграмм классов UML. Основные понятия и обозначения. Примеры.**

В UML предлагается использовать **три уровня** детализации диаграмм классов, соответствующие разным этапам разработки.

**Уровни диаграмм классов:**

1.  **Концептуальный уровень (этап анализа).**
    *   **Описание:** Диаграммы называют **контекстными**. Они демонстрируют связи между основными **понятиями** предметной области.
    *   **Обозначения:** Класс изображается как простой прямоугольник с **именем класса** внутри. Атрибуты и операции не указываются.
2.  **Уровень спецификаций (этап проектирования).**
    *   **Описание:** Диаграммы отображают **связи объектов классов**. Показывают интерфейсы, но не детали реализации.
    *   **Обозначения:** К имени класса добавляются **атрибуты**. Операции могут быть опущены.
3.  **Уровень реализации (этап реализации).**
    *   **Описание:** Диаграммы показывают **особенности проектирования конкретных классов**. Это наиболее подробный уровень.
    *   **Обозначения:** Класс изображается в виде прямоугольника, разделенного на три секции: **Имя класса**, **Атрибуты**, **Операции**.

**Основные понятия и обозначения:**

*   **Класс:** Прямоугольник с именем, атрибутами и операциями.
*   **Атрибут:** Свойство класса. Формат: `<видимость> <имя>: <тип> = <значение_по_умолчанию>`.
    *   `+` (public), `-` (private), `#` (protected).
*   **Операция (Метод):** Действие, которое может выполнять класс. Формат: `<видимость> <имя>(<параметры>): <тип_возврата>`.
*   **Отношения:**
    *   **Ассоциация:** Сплошная линия, обозначающая связь между классами. Может иметь имя, роли и множественность (1, *, 0..1).
    *   **Обобщение (Наследование):** Сплошная линия с незакрашенным треугольником, направленная от подкласса к суперклассу.
    *   **Агрегация:** Сплошная линия с **пустым ромбом** у класса-«целого». Означает отношение «целое-часть», где часть может существовать отдельно.
    *   **Композиция:** Сплошная линия с **закрашенным ромбом** у класса-«целого». Означает, что «часть» не может существовать без «целого».

**Примеры:**
*   **Концептуальный уровень:** Классы «Студент» и «Институт», соединенные линией ассоциации «Обучается».
*   **Уровень спецификаций:** К классу «Студент» добавляются атрибуты `-зачетнаяКнижка: int`, `-ФИО: string`.
*   **Уровень реализации:** К классу «Студент» добавляются операции `+сдатьЭкзамен()`, `+получитьСправку()`.

**[Источники: Диаграммы классов.pptx.ocr.txt, слайды 1-15; Проектирование при объектном подходе 2.pptx.ocr.txt, слайды 2-15]**

---

### **Вопрос 40. Назначение диаграммы последовательности. Основные понятия и графические обозначения. Пример диаграммы.**

**Назначение:**
*   Диаграмма последовательности (Sequence Diagram) отображает **взаимодействие объектов, упорядоченное по времени**.
*   Другое название — **«сценарий»**. Она позволяет описать один конкретный сценарий варианта использования.
*   Диаграмма показывает, какие **сообщения** и в какой последовательности объекты посылают друг другу.

**Основные понятия и графические обозначения:**
*   **Участник (Объект):** Прямоугольник наверху диаграммы с именем в формате `имяОбъекта:ИмяКласса`.
*   **Линия жизни:** Вертикальная пунктирная линия, идущая вниз от участника, представляет его существование во времени.
*   **Полоса активации (Фокус управления):** Узкий прямоугольник на линии жизни, показывает период, когда объект активен (выполняет операцию).
*   **Сообщение:** Стрелка между линиями жизни двух объектов.
    *   **Синхронное сообщение:** Сплошная линия с **закрашенной** стрелкой. Означает, что отправитель ждет ответа.
    *   **Асинхронное сообщение:** Сплошная линия с **открытой** стрелкой. Отправитель не ждет ответа и продолжает работу.
    *   **Ответ на сообщение:** Пунктирная линия с открытой стрелкой.
*   **Создание объекта:** Стрелка, указывающая на прямоугольник объекта, с пометкой `<<create>>` или именем конструктора (`new`).
*   **Уничтожение объекта:** Стрелка, указывающая на большой крест (`X`) на линии жизни объекта.

**Пример диаграммы:**
В материалах приведена диаграмма последовательности для варианта использования **«Регистрация»**.
*   **Участники:** `Студент` (актор) и `:System` (объект системы).
*   **Последовательность:**
    1.  `Студент` посылает синхронное сообщение `Открыть файл регистрации()` системе.
    2.  `Студент` посылает сообщение `Ввод ФИО(ФИО)`.
    3.  `:System` выполняет внутренние операции `Проверка на существование()` и `Записать в файл()`.
    4.  `:System` возвращает ответ студенту.

**[Источники: Проектирование при объектном подходе 2.pptx.ocr.txt, слайды 1-11]**

---

### **Вопрос 41. Назначение диаграммы деятельности. Условные обозначения и пример диаграммы.**

**Назначение:**
*   Представляет **обобщенное представление алгоритма** варианта использования или логики выполнения операции.
*   Позволяет описывать **альтернативные** (ветвления) и **параллельные** процессы.
*   Может быть представлена в виде **диаграммы по дорожкам**, где каждая дорожка соответствует определенному объекту или актору и показывает его сферу ответственности.

**Условные обозначения:**
*   **Начало:** Закрашенный кружок.
*   **Конец:** Закрашенный кружок внутри другого кружка.
*   **Деятельность (Действие):** Прямоугольник со скругленными углами, внутри которого описывается действие.
*   **Переход:** Сплошная стрелка, показывающая поток управления.
*   **Выбор (Решение):** Ромб, из которого выходят несколько переходов с условиями в `[]` скобках.
*   **Слияние:** Ромб, в который входит несколько переходов.
*   **Развилка (Fork) и Слияние (Join):** Толстая горизонтальная линия для обозначения начала и конца параллельных процессов.

**Пример диаграммы:**
Пример диаграммы для варианта использования **«Тестирование»**.
*   **Действия:** «Создание объекта теста», «Вывод вопроса и вариантов ответов», «Ввод номера варианта ответа», «Сохранение результата», «Уничтожить объект тест».
*   **Логика:** После ввода ответа стоит **ромб решения** «Ответ определен?». Если да — «Сохранение результата», если нет — возврат к «Ввод номера варианта ответа». Далее следует еще один ромб «Последний вопрос?», который определяет, переходить ли к следующему вопросу или уничтожать объект теста.

**[Источники: Проектирование при объектном подходе 2.pptx.ocr.txt, слайды 13-17]**

---

### **Вопрос 42. Разработка пользовательских интерфейсов. Классификация входных и выходных сообщений.**

**Пользовательский интерфейс** предназначен для организации **диалога** между человеком и ЭВМ. Диалог состоит из обмена **сообщениями**.

**Входное сообщение (порождается пользователем):**
*   **Запрос информации:** пользователь просит систему предоставить данные.
*   **Запрос помощи:** вызов справки.
*   **Приказ:** команда на выполнение действия (например, «Сохранить»).
*   **Ввод или изменение информации:** ввод текста в поле, изменение настроек.
*   **Выбор поля кадра:** установка фокуса на элемент управления.

**Выходное сообщение (формируется системой):**
*   **Подсказки:** всплывающие подсказки, информационные тексты.
*   **Информационные сообщения:** сообщения, не требующие ответа (например, «Файл успешно сохранен»).
*   **Вопросы, требующие ответа:** диалоговые окна с вопросом и кнопками Да/Нет.
*   **Приказы, требующие действий:** инструкция для пользователя.
*   **Сообщения об ошибках:** уведомления о неверных действиях пользователя.
*   **Изменения формата кадра:** например, сделать кнопку неактивной.

**[Источник: Разработка пользовательских интерфейсов.pptx.ocr.txt, слайд 2]**

---

### **Вопрос 43. Разработка пользовательских интерфейсов. Классификация по типу и виду управления интерфейса.**

Классификация интерфейсов помогает определить их характеристики и поведение.

**1. Классификация по типу диалога (этапы разработки):**

*   **Абстрактный:** Определяет основные свойства диалога (действия, реакции, инициаторы, возможности пользователя), не вдаваясь в детали реализации.
*   **Конкретный:** Связан с характеристикой сообщений (алфавит, словарь, форматы, семантика).
*   **Технический:** Обусловлен выбором аппаратных средств ввода и вывода.

**2. Классификация по виду управления:**

*   **Управляемые системой:** Система определяет сценарий диалога (например, пошаговый мастер установки).
*   **Управляемые пользователем:** Пользователь определяет сценарий, свободно выбирая действия (например, работа в графическом редакторе).
*   **Гибридное управление:** Сочетание обоих видов, часто встречается в сложных и интеллектуальных системах.

**[Источники: Разработка пользовательских интерфейсов.pptx.ocr.txt, слайды 5-7]**

---
Без проблем. Завершаем подготовку. Вот ответы на заключительную часть вопросов (44-48), составленные в том же четком стиле.

---

### **Вопрос 44. Разработка пользовательских интерфейсов. Формы диалога. Их достоинства и недостатки.**

В разработке пользовательских интерфейсов выделяют две основные формы диалога, которые, в свою очередь, делятся на более конкретные виды.

**1. Открытая форма (выбор и/или манипулирование элементами на экране)**
   *   **Меню и шаблоны:**
       *   **Описание:** Пользователю предлагается структурированный перечень элементов (меню) или поля для заполнения (шаблон). Эта форма, по сути, является подсказкой.
       *   **Достоинства:** Простое взаимодействие, легкость обучения, ориентация на пользователя-непрограммиста.
       *   **Недостатки:** Менее гибкая по сравнению с директивной формой.

**2. Закрытая форма (ввод элементов)**
   *   **Директивная форма:**
       *   **Описание:** Взаимодействие происходит через ввод команд (директив). Инициатором обмена всегда является пользователь.
       *   **Достоинства:** Большая гибкость, возможности выбора операций не ограничены.
       *   **Недостатки:** Требует повышенной квалификации пользователя.
   *   **Фразовая форма:**
       *   **Описание:** Используется ограниченный естественный язык. Инициатором шага может быть как пользователь, так и система.
       *   **Достоинства:** Более свободное общение с машиной, рассчитана на пользователя-непрограммиста.
       *   **Недостатки:** Большие затраты на разработку, не гарантируется однозначность формулировок, требуется ввод грамматически правильных фраз.

**[Источники: Разработка пользовательских интерфейсов.pptx.ocr.txt, слайды 8-11; Лекция 17.04.2025 (№ 13, 14).md, разделы "Директивная форма", "Меню и шаблоны", "Фразовая"]**

---

### **Вопрос 45. Способы взаимодействия человека и машины. Примеры использования.**

При организации диалога для одного пользователя выделяют два основных способа взаимодействия:

**1. Синхронный способ**
*   **Характеристики:**
    *   Партнеры диалога (человек и система) активизируются **поочередно**.
    *   Общение четко **регламентировано**.
    *   Ни один из партнеров не может прервать другого.
    *   Способ широко распространен и реализуется достаточно просто.
*   **Пример использования:** Пошаговый мастер установки программы (wizard). Пользователь выполняет действие (нажимает «Далее»), система реагирует, и только после этого пользователь может выполнить следующее действие. Другой пример — работа в командной строке, где пользователь ждет завершения команды перед вводом следующей.

**2. Асинхронный способ**
*   **Характеристики:** Обеспечивает возможность **нерегламентированного** взаимодействия.
    *   Система может выдавать **экстренные сообщения** (например, уведомления).
    *   Пользователь может отправлять **экстренные запросы** (например, прервать операцию).
*   **Пример использования:** Работа в современной ОС. Пользователь пишет текст в редакторе, а система в это время может вывести уведомление о низком заряде батареи, прервав основной поток взаимодействия.

**[Источник: Разработка пользовательских интерфейсов.pptx.ocr.txt, слайды 15-16]**

---

### **Вопрос 46. Назначение диаграммы состояний интерфейса. Графические обозначения. Пример диаграммы.**

Эта диаграмма идентична той, что описана в **вопросе 28**, но рассматривается в контексте интерфейса.

**Назначение:**
Диаграмма состояний (или **граф диалога**) используется для графического представления **структуры диалога** пользовательского интерфейса. Она моделирует поведение интерфейса как конечного автомата, показывая:
*   Все возможные **состояния**, в которых может находиться интерфейс.
*   **Переходы** между этими состояниями, вызванные действиями пользователя или системы.

**Графические обозначения:**
*   **Состояние:** Вершина графа, обычно изображается как **прямоугольник со скругленными углами** (промежуточное состояние), **закрашенный круг** (начальное) или **круг с точкой** (конечное).
*   **Переход:** Дуга (стрелка) между двумя состояниями, которая определяет смену состояния.

**Пример диаграммы:**
В материалах приведена простая диаграмма состояний интерфейса:
*   **S0:** Начальное состояние (например, главное меню).
*   **S1:** Состояние ввода данных (например, открыта форма для заполнения).
*   **S2:** Конечное состояние (например, работа с программой завершена).
Переход из S0 в S1 может быть вызван выбором пункта меню, а из S1 в S2 — нажатием кнопки «Сохранить».

**[Источники: Разработка пользовательских интерфейсов.pptx.ocr.txt, слайд 18; ТРПS_Lektsiya_24_-_32.pptx.ocr.txt, слайды 11-13]**

---

### **Вопрос 47. Принципы проектирования программных продуктов. Примеры использования.**

В основе современного проектирования (объектного подхода) лежит **объектная декомпозиция**, которая опирается на следующие принципы (первые четыре являются обязательными):

1.  **Абстрагирование.** Процесс выделения существенных характеристик объекта и игнорирования несущественных.
    *   *Пример:* При проектировании класса `Автомобиль` мы абстрагируемся от материала шин и цвета обивки сидений, но выделяем такие характеристики, как `скорость`, `цвет_кузова` и операции `ехать()`, `тормозить()`.
2.  **Ограничение доступа (Инкапсуляция).** Процесс защиты внутренних элементов объекта от прямого неконтролируемого доступа извне. Доступ к данным осуществляется через открытые методы.
    *   *Пример:* Поле `баланс` в классе `БанковскийСчет` является скрытым (private). Изменить его можно только через публичные методы `пополнить()` и `снять()`, которые содержат необходимые проверки.
3.  **Модульность.** Декомпозиция системы на ряд отдельно реализуемых модулей.
    *   *Пример:* Система интернет-магазина разбивается на модули: `Модуль_авторизации`, `Каталог_товаров`, `Корзина`, `Модуль_оплаты`.
4.  **Иерархия.** Ранжированная (упорядоченная) система абстракций. Основной механизм реализации — **наследование**.
    *   *Пример:* Классы `Грузовик` и `Легковой_автомобиль` наследуются от общего класса `Автомобиль`, перенимая его общие свойства и методы, но добавляя свои уникальные.
5.  **Типизация.** Ограничение, препятствующее взаимозаменяемости объектов различных классов.
6.  **Параллелизм.** Свойство нескольких объектов одновременно находиться в активном или пассивном состоянии.
7.  **Устойчивость.** Свойство объекта существовать во времени (независимо от процесса, который его породил) или в пространстве (возможность перемещения между адресными пространствами).

**[Источник: Проектирование при объектном подходе.pptx.ocr.txt, слайды 1-5]**

---

### **Вопрос 48. Семантический интерфейс. Принцип работы лингвистического процессора.**

**Семантический интерфейс** — это интерфейс, позволяющий взаимодействовать с системой на **естественном языке** (или его ограниченном подмножестве), то есть использующий **фразовую форму диалога**. Его главная задача — понять **смысл (семантику)** запроса пользователя.

**Принцип работы лингвистического процессора** (ядра семантического интерфейса) можно описать как конвейер из нескольких этапов:

1.  **Лексический анализ:** Входное предложение на естественном языке разбивается на отдельные слова (лексемы) и знаки препинания.
2.  **Морфологический анализ:** Каждая словоформа анализируется с помощью словаря. Для слова определяется его начальная форма (лемма), часть речи, падеж, число и т.д. (например, для слова «столами» определяется, что это существительное «стол» в творительном падеже, мн. ч.).
3.  **Синтаксический анализ:** На основе информации от морфологического анализатора и набора правил грамматики строится синтаксическая структура предложения (дерево разбора). Определяются главные и второстепенные члены предложения, их связи.
4.  **Семантический анализ:** На этом этапе определяется **смысл** предложения. Выявляются смысловые отношения между словами (кто/что является субъектом, объектом, какое действие выполняется) и главные предикаты. Результатом является формальное представление смысла, например, в виде семантической сети или графа.

**[Источники: Разработка пользовательских интерфейсов.pptx.ocr.txt, слайды 12-14; Лекция 17.04.2025 (№ 13, 14).md, раздел "Обработка фраз"]**

---


