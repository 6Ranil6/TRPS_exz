
[[ТРПС/Лекции/Лекции|Лекции]]

---
---
---
# ТЕМА 6. ПРОДОЛЖЕНИЕ

---
В соответствии с ==ГОСТ 19.101-90== программы подразделяются на следующие виды:
- **КОМПОНЕНТ.** Это программа, рассматриваемая как единое целое и выполняющая законченную функцию. Может применяться самостоятельное или в составе комплекса.
- **КОМПЛЕКС.** Это программный продукт, состоящий из двух или более компонентов и (или) комплексов, которые выполняют взаимосвязанные функции. Может применяться самостоятельно или в составе другого комплекса.

---
#### **МОДУЛЬНЫЙ ПОДХОД**

**Модуль** — это отдельная часть программы, допускающая сепаратную компиляцию и сборку с другими блоками. (Модуль может быть очень сложной структурой (со своей иерархией и т.п.))

*В частности, под модулем понимают отдельно компилируемую библиотеку ресурсов.*

С другой стороны модуль одновременно может быть и ***функциональной компонентой программы***.

---
###### ***Преимущества использования модулей:***
- Возможность одновременной работы нескольких человек;
- Возможность создания библиотек стандартных модулей;
- Возможность подзагрузки модулей в оперативную память;
	![[Pasted image 20250327121450.png]]
	Разбивая программу на модули, мы позволяем системе загружать программу в оперативную память по частям, что позволяет организовать работу сразу нескольких программ (программа-монолит может не уместиться в ОП целиком).

- Большое количество естественных точек для тестирования *(за счёт разбиения на модули появляется выходные параметры после работы каждого модуля, поэтому образуется возможность тестировать каждый модуль отдельно)*;
- Упрощают проектирование и модификацию программы; 

---
###### ***НЕДОСТАТКИ:***
- Увеличение времени выполнения за счёт организации межмодульных связей;
- Увеличение времени компиляции и загрузки;
- Код программы и тексты занимают больше памяти;

---
Чтобы определить насколько удачно была проведена разбивка системы на модули, ==модно оценить степень независимости модулей== (как подпрограмм, так и библиотек).

**Для этого используют критерии: *СЦЕПЛЕНИЕ* и *СВЯЗНОСТЬ*.**

---
###### **СЦЕПЛЕНИЕ**
Характеризует качество отделения модулей.
Различаются *пять типов* сцепления модулей:
- **ПО ДАННЫМ** (Модули обмениваются данными представленными скалярными значениями;
- **ПО ОБРАЗЦУ** (Модули обмениваются данными, объединяются в структуры). Например:  Function Max(a:array of integer):integer; где а - открытый массив;
- **ПО УПРАВЛЕНИЮ** (Например, в качестве параметров передаются управляющие данные (флаги), от которых зависит алгоритм работы модуля или режим);
- **ПО ОБЩЕЙ ОБЛАСТИ ДАННЫХ** (не рекомендуется использовать, т.к. усложняется локализация ошибок, уменьшается гибкость пространства имён);
- **ПО СОДЕРЖИМОМУ** (Один модуль содержит обращения к внутренним компонентам другого). Языки высокого уровня такое сцепление не поддерживают, но языки низкого уровня, например Ассемблер *позволяют*.

---
###### **СВЯЗНОСТЬ**
Характеризует степень взаимосвязи элементов, реализуемых одним модулем.

Размещение **сильно связанных** элементов в одном модуле **уменьшает** межмодульные связи.

И наоборот, размещение **сильно связанных элементов** в разные модули **усиливает** межмодульные связи.

![[Pasted image 20250327123405.png]]

---
Различают следующие виды связности:
- **ФУНКЦИОНАЛЬНУЮ** (компоненты модуля предназначены для выполнения одной функции);
- **ПОСЛЕДОВАТЕЛЬНУЮ** (выход одной функции служит исходными данными для другой функции);
- **ИНФОРМАЦИОННУЮ** (компоненты обрабатываются одни и те же данные);
- **ПРОЦЕДУРНУЮ** (функции или данные являются частями одного процесса);
- **ВРЕМЕННУЮ** (функции выполняются параллельно или в течение некоторого периода времени, а данные используются в некотором временном интервале);
- **ЛОГИЧЕСКУЮ** (модуль с логической связностью функций часто реализует альтернативные варианты одной операции);
- **СЛУЧАЙНУЮ** (связь между элементами практически отсутствует).
Как правило, **модули верхних уровней иерархии** имеют *функциональную* или *последовательную* связность функций и данных.

---
#### **ПРИНЦИП ВЕРТИКАЛЬНОГО УПРАВЛЕНИЯ** 
При проектировании системы строится:
	а) Схема иерархии отдельных программ;
	б) Схема иерархии отдельных модулей *(проектирование следует начинать с вершины)*
	![[Pasted image 20250327124341.png]]
#дописать 0:49:00

---
**Передача управления** происходит лишь по вертикальным линиям, соединяющих модули в схеме иерархии. Вертикальное управление происходит по следующим правилам.
**СВОЙСТВА МОДУЛЕЙ:**
- **Должен** возвращать управление модулю, который его вызвал;
- **Может** вызывать другие модули уровнем ниже, но не может вызывать модуль своего уровня или выше (кроме случаев рекурсии);
- **Должен** иметь одну точку входа и одну точку выхода;
- **Должен** быть сравнительно невелик (50-60 операторов);
- Один модуль **должен** выполнять по возможности одну функцию определённого уровня;
- Модуль **должен** быть независим от истории вызовов;

---
###### ***ПРЕИМУЩЕСТВА ВЕРТИКАЛЬНОГО УПРАВЛЕНИЯ***
- Логика программы более понятна;
- При чтении головного модуля проявляется логика всей программы;
- Программу проще изменять и дополнять;
- Позволяет быстро обнаружить логические ошибки;

---
#### **ТЕХНОЛОГИЧНОСТЬ**
#важно Под **технологичностью** понимают **качество** проекта ПП, от которого зависят трудовые и материальные затраты на его реализацию и последующую модификацию.
**ХОРОШИЙ ПРОЕКТ** сравнительно быстро и легко *кодируется, тестируется, отлаживается и модифицируется*.

---
**Технологичность ПП определяется:** ПРОРАБОТАННОСТЬЮ ОШИБОК.

Хорошая проработка означает, что:
- чётко определены подзадачи;
- чётко определены структуры данных;

Уменьшает количество ошибок, из-за которых потребуется существенно изменять программу.

---
###### **Уровень независимости модулей**
Практика показала, что чем выше независимость, тем:
- **Легче понять** работу, как отдельного модуля, так и всей программы;
- **Легче наращивать** функциональность программной системы;
- **Меньше** вероятность появления *"волнового" эффекта*;
- **Проще** организовать разработку *группой программистов* и легче его *сопровождать*.

---
###### **Стиль программирования**
*Это набор правил, которым следует программист.*

Хороший стиль предполагает:
- Использование комментариев;
- Использование **со смыслом** имён переменных, процедур, функций и др.;
- Использование отступов и пустых строк;

**От стиля зависят:** 
- количество ошибок при наборе текста;
- читаемость программы;
- процессы отладки и внесения изменений;

---
###### **Степень повторного использования кодов**
**Повторное использование** — основная методология, которая применяется *для сокращения трудозатрат* при разработке сложных систем.

Увеличение степени предполагает:
- Использование ранее разработанных библиотек;
- Унификацию кодов текущей разработки;

---
---
---
# **ТЕМА 7. СТРУКТУРНАЯ КАРТА КОНСТАНТАЙНА**
(см. следующую лекцию)
