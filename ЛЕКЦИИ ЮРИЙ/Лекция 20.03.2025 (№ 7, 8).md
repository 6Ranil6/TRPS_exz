
[[ТРПС/Лекции/Лекции|Лекции]]

---
---
---

![[Pasted image 20250320120115.png]]
Двоичные коды                          Ассемблеры                      Языки

---
#### СТРУКТУРНОЕ ПРОГРАММИРОВАНИЕ
Подразумевает использование в программе только три вида структур:
1) Следование
2) Развилка
3) Повторение
Названия созвучные с названиями структур схем алгоритмов:
	1) Линейная
	2) Разветвление
	3) Циклическая

---
Было доказано, что вышеуказанных видов структур достаточно, чтобы решить любую логическую задачу.
***Главная идея доказательства:***
1) Брали неструктурированную программу ("монолит")
2) Осуществляли преобразование отдельных частей в одну и трёх структур или их комбинацию
3) После преобразований неструктурированная часть исчезала, либо становилась ненужной
==По существу, речь идёт о структурах операторов языка.==
![[Pasted image 20250320121142.png]]
Понятие ==*СЛЕДОВАНИЕ*== в структурном программировании: Такое ***следование*** подразумевает, что управление передаётся от одного функционального узла к другому, т.е. **операторы выполняются в порядке их записи**.

---
![[Pasted image 20250320121348.png]]

---
- Вышеприведённые структуры реализуются операторами языка Паскаль.
- В других языках могут быть отклонения.
- В языке Пролог отсутствуют операторы, реализующие такие структуры.
Использование принципов структурного программирования даёт следующие возможности:
- Делает тексты даже больших программ легко читаемыми
- Кроме автора программу могут легко понять другие программисты
- Сокращается число вариантов построения программы по одной и той же спецификации, что значительно снижает сложность программ
- Упрощает процесс тестирования и отладки структурированных программ

---
---
---
# **ТЕМА 5. ПОДХОДЫ И СХЕМЫ РАЗРАБОТКИ**
#### НИСХОДЯЩИЙ ПОДХОД
Проектирование и последующая реализация компонентов выполняется *"сверху-вниз"*.
- Вначале проектируют компоненты **верхних** уровней иерархии, затем следующих и т.д. до **самых нижних** уровней.
- В той же последовательности выполняют и реализацию компонент.
- При этом компоненты нижних, ещё не реализованных уровней ==заменяют "заглушками"== *(заглушка — элемент, который закрывает собой ещё неразработанную часть продукта (пример: кнопка для функции, которая ещё не реализована, выдаёт сообщение о временном отсутствии данной функции))*, что позволяет тестировать и отлаживать уже реализованную часть.

---
#### МЕТОДЫ В РАМКАХ НИСХОДЯЩЕГО ПОДХОДА
**Это методы** определения последовательности проектирования и реализации компонентов.
Выделяют следующие методы:
- ***ИЕРАРХИЧЕСКИЙ*** — предполагает выполнение разработки строго по уровням, если нет зависимости по данным. **Основная проблема** — большое количество *сложных* заглушек
![[Pasted image 20250320142742.png]]
- ***ОПЕРАЦИОННЫЙ*** — связывает последовательность разработки модулей с *порядком их использования*.
![[Pasted image 20250320143351.png]]
*Красная область — самые часто используемые модули.*

- ***КОМБИНИРОВАННЫЙ*** — в создаваемом проекте выделяются ключевые модули, которые необходимо реализовывать первыми. Факторы, влияющие на план последовательности реализации модулей:
	- Достижимость модуля
	- Зависимость по модулям
	- Возможности выдачи результатов
	- Наличие вспомогательных модулей
	- Наличие необходимых ресурсов
	
	При прочих равных:
	- Сложные модули должны разрабатываться ==раньше== простых (так как на тестирование сложных модулей будет выделено **больше** времени).
	- Если некоторый компонент нижнего уровня *используется многими* компонентами более высоких уровней, то ==можно нарушить последовательность и разработать сначала *нижний* модуль==.
	- Компоненты *обработки правильных и неправильных данных* разрабатываются в следующем порядке: ==1) Правильные, 2) Неправильные==.
---
#### НИСХОДЯЩИЙ ПОДХОД ОБЕСПЕЧИВАЕТ:
- Максимально полное определение спецификаций компонентов и их согласованность между собой;
- Раннее определение интерфейса пользователя (заказчик может уточнить требования);
- Возможность комплексной отладки на ранних стадиях;
**Нисходящий подход *обычно используют* при объектно-ориентированном программировании**.

---
### ПОДХОД — "РАСШИРЕНИЕ ЯДРА"
Предполагает:
- В первую очередь проектировать и реализовывать некоторую основу — ядро;
- Затем ядро наращивают, комбинируя восходящий и нисходящий методы;
- При создании самого ядра используют один из вышеуказанных методов;

---
---
Тут таблица с должностями
(можно и не добавлять)

---
---
---
# ТЕМА 6. АРХИТЕКТУРА И МОДУЛЬНЫЙ ПОДХОД
### Архитектура ПП
Определяется:
- Сложностью решаемых задач;
- Степенью универсальности;
Различают следующие архитектуры:
- Программа
- Пакеты программ
- Программные комплексы
- Программные продукты

---
***Программа*** — адресует компьютеру *набор инструкций*, точно описывающий последовательность действий *для решения конкретной задачи*.
![[Pasted image 20250327195919.png]]

---
***Пакеты программ*** — представляют собой *совокупность* программ, решающих задачи некоторой прикладной области.
![[Pasted image 20250327195932.png]]

---
***Программные комплексы*** — представляют собой *совокупность программ*, **совместно** обеспечивающих решение **небольшого класса сложных задач одной прикладной области**. *(вызов программ в программном комплексе осуществляется специальной программой — диспетчером, который обеспечивает несложный интерфейс с пользователем).*
![[Pasted image 20250327195954.png]]

---
***Программные системы*** — представляют собой *организованную совокупность* программ (подсистем), позволяющую решать *широкий класс задач* из некоторой прикладной области.

В отличие от программных комплексов:
- Программы взаимодействуют через общие данные ;
- Имеют развитый пользовательский интерфейс;
- Имеют развитый внутренний интерфейс;
- *Решают ШИРОКИЙ класс задач*
![[Pasted image 20250327200100.png]]

---
